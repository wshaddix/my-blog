<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8" />

  
  <title>Three Node Docker Swarm with Ubuntu 17.04 on Azure</title>

  
  





  
  <meta name="author" content="Wes Shaddix" />
  <meta name="description" content="[Updated] 12&amp;frasl;28 - Improved the setup so that we can use a load balancer in front of the swarm nodes as well as improve the availability of the swarm nodes
Overview I&amp;rsquo;m learning docker swarm mode and need a realistic simulation of setting up a multi-node cluster. Azure is an ideal platform to test things out. My goal is to create a docker swarm cluster within a single region. Creating a multi-region swarm cluster requires creating virutal networks in different regions and connecting those vnets through a vpn gateway which is not something I&amp;rsquo;m ready to tackle just yet." />

  
  
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@wshaddix" />
    <meta name="twitter:title" content="Three Node Docker Swarm with Ubuntu 17.04 on Azure" />
    <meta name="twitter:description" content="[Updated] 12&amp;frasl;28 - Improved the setup so that we can use a load balancer in front of the swarm nodes as well as improve the availability of the swarm nodes
Overview I&amp;rsquo;m learning docker swarm mode and need a realistic simulation of setting up a multi-node cluster. Azure is an ideal platform to test things out. My goal is to create a docker swarm cluster within a single region. Creating a multi-region swarm cluster requires creating virutal networks in different regions and connecting those vnets through a vpn gateway which is not something I&amp;rsquo;m ready to tackle just yet." />
    <meta name="twitter:image" content="http://www.wesshaddix.com/img/avatar.jpg" />
  




<meta name="generator" content="Hugo 0.31.1" />


<link rel="canonical" href="http://www.wesshaddix.com/post/three-node-docker-swarm-cluster/" />
<link rel="alternative" href="http://www.wesshaddix.com/index.xml" title="Wes Shaddix" type="application/atom+xml" />


<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />


<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />







<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Wes Shaddix" />
<meta name="msapplication-tooltip" content="Wes Shaddix" />
<meta name='msapplication-navbutton-color' content="#5fbf5e" />
<meta name="msapplication-TileColor" content="#5fbf5e" />
<meta name="msapplication-TileImage" content="/img/tile-image-windows.png" />
<link rel="icon" href="http://www.wesshaddix.com/img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="http://www.wesshaddix.com/img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="http://www.wesshaddix.com/img/favicon-32x32.png" />
<link rel="icon" sizes="192x192" href="http://www.wesshaddix.com/img/touch-icon-android.png" />
<link rel="apple-touch-icon" href="http://www.wesshaddix.com/img/touch-icon-apple.png" />
<link rel="mask-icon" href="http://www.wesshaddix.com/img/safari-pinned-tab.svg" color="#5fbf5e" />



<link rel="stylesheet" href="//cdn.bootcss.com/video.js/6.2.8/alt/video-js-cdn.min.css" />

<link rel="stylesheet" href="http://www.wesshaddix.com/css/bundle.css" />
<link rel="stylesheet" href="http://www.wesshaddix.com/css/custom.css" />


  
  <!--[if lt IE 9]>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <script src="//cdn.bootcss.com/video.js/6.2.8/ie8/videojs-ie8.min.js"></script>
  <![endif]-->

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
  <![endif]-->


<script src="//cdn.bootcss.com/object-fit-images/3.2.3/ofi.min.js"></script>


<script src="//cdn.bootcss.com/smooth-scroll/12.1.4/js/smooth-scroll.polyfills.min.js"></script>


</head>
  <body>
    
    <div class="suspension">
      <a title="Go to top" class="to-top is-hide"><span class="icon icon-up"></span></a>
      
        
        <a title="Go to comments" class="to-comment" href="#disqus_thread"><span class="icon icon-comment"></span></a>
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="http://www.wesshaddix.com/img/avatar.jpg" alt="Avatar">
  
  <h2 class="title">Wes Shaddix</h2>
  
  <p class="subtitle"></p>
  <button class="menu-toggle" type="button">
    <span class="icon icon-menu"></span>
  </button>
  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
            
            
            
              is-active
            ">
            <a href="http://www.wesshaddix.com/">My Blog</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="https://github.com/wshaddix">My Projects</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="http://www.wesshaddix.com/tags/">Tags</a>
          </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list">

      
      <li class="social-item">
        <a href="mailto:wes.shaddix@outlook.com" title="Email"><span class="icon icon-email"></span></a>
      </li>

      
      <li class="social-item">
        <a href="//github.com/wshaddix" title="GitHub"><span class="icon icon-github"></span></a>
      </li>

      <li class="social-item">
        <a href="//twitter.com/wshaddix" title="Twitter"><span class="icon icon-twitter"></span></a>
      </li>

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <li class="social-item">
        <a href="http://www.wesshaddix.com/index.xml"><span class="icon icon-rss" title="RSS"></span></a>
      </li>

    </ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">Three Node Docker Swarm with Ubuntu 17.04 on Azure</h1>
      <p class="post-meta">@Wes Shaddix · Dec 28, 2017 · 11 min read</p>
    </header>
    <article class="post-content">

<p><strong>[Updated] <sup>12</sup>&frasl;<sub>28</sub> - Improved the setup so that we can use a load balancer in front of the swarm nodes as well as improve the availability of the swarm nodes</strong></p>

<h1 id="overview">Overview</h1>

<p>I&rsquo;m learning docker swarm mode and need a realistic simulation of setting up a multi-node cluster. Azure is an ideal platform to test things out. My goal is to create a docker swarm cluster within a <strong>single</strong> region. Creating a multi-region swarm cluster requires creating virutal networks in different regions and connecting those vnets through a vpn gateway which is not something I&rsquo;m ready to tackle just yet.</p>

<h2 id="my-setup">My setup</h2>

<p>I&rsquo;m running a windows 10 workstation with docker for windows.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">λ ver
Microsoft Windows <span style="color:#66d9ef">[Version 10.0.16299.125]</span>

λ docker --version
Docker version 17.09.1-ce, build 19e2cf6</code></pre></div>
<h2 id="getting-the-azure-cli-v2">Getting the azure cli v2</h2>

<p>I know I want to use the Azure CLI v2 in order to be able to manage my azure resources from the command line but I don&rsquo;t want to have to install/configure it along with whatever programming languages it requires. Instead I just want to use it from a docker image. In order to do that, I need to download and run it in a container so from my <strong>powershell</strong> terminal I run</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">docker run --rm -v ${HOME}<span style="color:#960050;background-color:#1e0010">:</span>/root -it azuresdk/azure-cli-python<span style="color:#960050;background-color:#1e0010">:</span>latest</code></pre></div>
<p>This will run a container that has the azure cli ready to go. The <code>--rm</code> argument means that the container will be removed once I exit from it. The <code>-v ${HOME}:/root</code> argument maps my home directory on my Windows 10 host to the /root folder inside the docker container. This means anything written to the /root folder in the container will be saved on my host machine and be available the next time I run the container. Finally the <code>-it</code> argument will put me at the terminal of the container where I can interact with it.</p>

<h2 id="logging-into-my-azure-account">Logging into my azure account</h2>

<p>Now that I have access to the Azure CLI, I need to authenticate to my Azure account. To do that I run</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">az login</code></pre></div>
<p>When you run this command it will give you a url along with a code. Simply open the url in your web browser and paste in the code and it will authorize your Azure CLI to access your Azure account.</p>

<h2 id="the-script">The script</h2>

<p>I&rsquo;m going to show the entire script here that you can run from the azure cli for convenience. In the rest of this post I&rsquo;ll describe what each command does.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">RESOURCE_GROUP<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;dev-docker-swarm-us-east&#34;</span>
VNET_NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;vnet-docker-swarm&#34;</span>
SUBNET_NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;subnet-docker-swarm&#34;</span>
NSG_NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;nsg-docker-swarm&#34;</span>
LOAD_BALANCER_NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;load-balancer-swarm-cluster&#34;</span>
OS_IMAGE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Canonical:UbuntuServer:17.04:17.04.201711210&#34;</span>
VM_SIZE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Standard_B2S&#34;</span>
ADMIN_USERNAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;wshaddix&#34;</span>
AVAILABILITY_SET_NAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;availability-set-swarm-nodes&#34;</span>

<span style="color:#75715e"># create a resource group
</span><span style="color:#75715e"></span>az group create -l eastus -n $RESOURCE_GROUP

<span style="color:#75715e"># create a network security group
</span><span style="color:#75715e"></span>az network nsg create -g $RESOURCE_GROUP -n $NSG_NAME

<span style="color:#75715e"># create a virtual network
</span><span style="color:#75715e"></span>az network vnet create -g $RESOURCE_GROUP -n $VNET_NAME

<span style="color:#75715e"># create a subnet
</span><span style="color:#75715e"></span>az network vnet subnet create -g $RESOURCE_GROUP -n $SUBNET_NAME --vnet-name $VNET_NAME --address-prefix <span style="color:#ae81ff">10</span>.0.0.0/24 --network-security-group $NSG_NAME

<span style="color:#75715e"># create a public ip address for the load balancer (front-end)
</span><span style="color:#75715e"></span>az network public-ip create -g $RESOURCE_GROUP -n $LOAD_BALANCER_NAME-ip

<span style="color:#75715e"># create a load balancer
</span><span style="color:#75715e"></span>az network lb create -g $RESOURCE_GROUP -n $LOAD_BALANCER_NAME --public-ip-address $LOAD_BALANCER_NAME-ip --frontend-ip-name $LOAD_BALANCER_NAME-front-end --backend-pool-name $LOAD_BALANCER_NAME-back-end

<span style="color:#75715e"># create a load balancer probe on port 80
</span><span style="color:#75715e"></span>az network lb probe create -g $RESOURCE_GROUP -n load-balancer-health-probe-80 --lb-name $LOAD_BALANCER_NAME --protocol tcp --port <span style="color:#ae81ff">80</span>

<span style="color:#75715e"># create a load balancer traffic rule for port 80
</span><span style="color:#75715e"></span>az network lb rule create -g $RESOURCE_GROUP -n load-balancer-traffic-rule-80 --lb-name $LOAD_BALANCER_NAME --protocol tcp --frontend-port <span style="color:#ae81ff">80</span> --backend-port <span style="color:#ae81ff">80</span> --frontend-ip-name $LOAD_BALANCER_NAME-front-end  --backend-pool-name $LOAD_BALANCER_NAME-back-end --probe-name load-balancer-health-probe-80

<span style="color:#75715e"># create three NAT rules for port 22 (so we can ssh to each of the three nodes via the load balancer&#39;s public ip address)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> i in <span style="color:#e6db74">`</span>seq <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span><span style="color:#e6db74">`</span>; <span style="color:#66d9ef">do</span>
  az network lb inbound-nat-rule create -g $RESOURCE_GROUP -n nat-rule-for-node-$i-ssh --lb-name $LOAD_BALANCER_NAME --protocol tcp --frontend-port <span style="color:#ae81ff">422</span>$i --backend-port <span style="color:#ae81ff">22</span> --frontend-ip-name $LOAD_BALANCER_NAME-front-end
<span style="color:#66d9ef">done</span>

<span style="color:#75715e"># allow port 22 (ssh) traffic into the network
</span><span style="color:#75715e"></span>az network nsg rule create -g $RESOURCE_GROUP -n allow-ssh --nsg-name $NSG_NAME --destination-port-ranges <span style="color:#ae81ff">22</span> --access Allow --description <span style="color:#e6db74">&#34;Allow inbound ssh traffic&#34;</span> --priority <span style="color:#ae81ff">100</span>

<span style="color:#75715e"># allow port 80 (http) traffic into the network
</span><span style="color:#75715e"></span>az network nsg rule create -g $RESOURCE_GROUP -n allow-http --nsg-name $NSG_NAME --destination-port-ranges <span style="color:#ae81ff">80</span> --access Allow --description <span style="color:#e6db74">&#34;Allow inbound http traffic&#34;</span> --priority <span style="color:#ae81ff">200</span>

<span style="color:#75715e"># create three virtual network cards and associate with the network security group and load balancer. bind each NIC to one of the ssh nat rules we created
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> i in <span style="color:#e6db74">`</span>seq <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span><span style="color:#e6db74">`</span>; <span style="color:#66d9ef">do</span>
  az network nic create -g $RESOURCE_GROUP -n node-$i-private-nic --vnet-name $VNET_NAME --subnet $SUBNET_NAME --lb-name $LOAD_BALANCER_NAME --lb-address-pools $LOAD_BALANCER_NAME-back-end --lb-inbound-nat-rules nat-rule-for-node-$i-ssh
<span style="color:#66d9ef">done</span>

<span style="color:#75715e"># create an availability set with 3 fault domains and 3 update domains
</span><span style="color:#75715e"></span>az vm availability-set create -g $RESOURCE_GROUP -n $AVAILABILITY_SET_NAME --platform-fault-domain-count <span style="color:#ae81ff">3</span> --platform-update-domain-count <span style="color:#ae81ff">3</span>

<span style="color:#75715e"># generate ssh keys
</span><span style="color:#75715e"></span>ssh-keygen -t rsa -f ~/.ssh/docker_rsa -N <span style="color:#e6db74">&#34;&#34;</span>

<span style="color:#75715e"># create three virtual machines
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> i in <span style="color:#e6db74">`</span>seq <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">3</span><span style="color:#e6db74">`</span>; <span style="color:#66d9ef">do</span>
  az vm create -g $RESOURCE_GROUP -n node-$i --ssh-key-value <span style="color:#e6db74">&#34;~/.ssh/docker_rsa.pub&#34;</span> --nics node-$i-private-nic --image $OS_IMAGE --size $VM_SIZE --authentication-type ssh --admin-username $ADMIN_USERNAME --availability-set $AVAILABILITY_SET_NAME --os-disk-name node-$i-os-disk
<span style="color:#66d9ef">done</span></code></pre></div>
<h2 id="create-a-resource-group">Create a resource group</h2>

<p>In order to be able to easily organize and later remove any and all resources that are related to the docker swarm cluster I put everything in a resource group. Resource groups are bound to geographic locations so I created one that is close to my location. The location could be <a href="https://azure.microsoft.com/en-us/regions/">anywhere that Azure supports</a>.</p>

<h2 id="create-a-network-security-group">Create a network security group</h2>

<p>We want to protect our network traffic with a firewall so we create a new network security group next. We need the network security group to exist before we create our virtual network and subnet so that we can associate the subnet to the network security group. That way, any rules that we create in the firewall will apply to everything connected to the subnet. This way we don&rsquo;t have to manage rules for each individual NIC that gets attached to the subnet but instead we can manage the subnet as a whole.</p>

<h2 id="create-a-virtual-network">Create a virtual network</h2>

<p>We start off by creating a network that each of the swarm nodes will connect to. We also create a subnet within the network to isolate traffic between the nodes.</p>

<h2 id="create-a-subnet">Create a subnet</h2>

<p>We create a subnet within the virtual network and associate it to the network security group that we created previously. Any rules that we create later on for the firewall will apply to everything in this subnet.</p>

<h2 id="create-a-public-ip-address-for-the-load-balancer-front-end">Create a public ip address for the load balancer (front-end)</h2>

<p>Now that we have a network setup we&rsquo;ll start creating a load balancer that will balance traffic between each node in the swarm cluster. There will only be one public ip to the swarm cluster and that will be the ip address of the load balancer.</p>

<h2 id="create-a-load-balancer">Create a load balancer</h2>

<p>Next we create a load balancer and associate it with the public ip address that we just created. The load balancer has a front-end ip and a back-end ip address pool that it balances traffic between.</p>

<h2 id="create-a-load-balancer-probe-on-port-80">Create a load balancer probe on port 80</h2>

<p>The load balancer has to have a way to detect if the nodes are healthy that it sends traffic to. We create a probe that will connect with each node using tcp port 80 traffic. If the node responds then the load balancer knows that the node is ready to receive traffic.</p>

<h2 id="create-a-load-balancer-traffic-rule-for-port-80">Create a load balancer traffic rule for port 80</h2>

<p>With the health probe in place, next we setup a traffic rule in the load balancer to forward tcp port 80 traffic to the nodes that are in the back-end pool. We associate this traffic rule with the health probe that we created.</p>

<h2 id="create-three-nat-rules-for-port-22-so-we-can-ssh-to-each-of-the-three-nodes-via-the-load-balancer-s-public-ip-address">Create three NAT rules for port 22 (so we can ssh to each of the three nodes via the load balancer&rsquo;s public ip address)</h2>

<p>To finish out the load balancer setup we need to create NAT rules that will allow us to reach each individual node in the cluster when we need to manage it via ssh. In order to do this, we setup rules that will route tcp port 4221, 4222 and 4223 traffic to port 22 (the ssh port) in the back-end pool. The key thing is that we name each NAT rule with a unique name that we will later use to bind to the NICs of the swarm nodes. This is what will allow us to ssh to port 4221, 4222 and 4223 and connect to node 1, node 2 and node 3 behind the load balancer.</p>

<h2 id="allow-port-22-ssh-traffic-into-the-network">Allow port 22 (ssh) traffic into the network</h2>

<p>In order to get tcp port 22 traffic into the network we have to allow for it in the firewall (network security group or NSG).</p>

<h2 id="allow-port-80-http-traffic-into-the-network">Allow port 80 (http) traffic into the network</h2>

<p>Just like port 22 ssh traffic above, we also have to let tcp port 80 traffic into the network.</p>

<h2 id="create-three-virtual-network-cards">Create three virtual network cards</h2>

<p>In order to connect the swarm nodes together we have to create a NIC for them and associate the NICs with the subnet that we previously setup. We give each NIC a unique name, we place it into the load balancer&rsquo;s back-end pool and we also associate the NIC with the uniquely named inbound NAT rule that we setup in order to allow us to reach the node via the load balancer for ssh traffic.</p>

<h2 id="create-an-availability-set-with-3-fault-domains-and-3-update-domains">Create an availability set with 3 fault domains and 3 update domains</h2>

<p>The virtual machines that we setup as swarm nodes must all be in the same availability set in order for the load balancer to be able to route traffic to them. You can read more about availability sets <a href="https://docs.microsoft.com/en-us/azure/virtual-machines/linux/manage-availability?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json">here</a> but in essence, what an availability set does is gives you a way to ensure that not all of your vm nodes will be rebooted at the same time (update domains) and provisions them across different physical hardware (fault domains) in order to increase their availability and up-time. In a future post I&rsquo;d like to explore using the new preview feature of <a href="https://docs.microsoft.com/en-us/azure/availability-zones/az-overview">Availability Zones</a> to further improve the fault tolerance of the swarm cluster.</p>

<h2 id="generate-ssh-keys">Generate ssh keys</h2>

<p>In order to manage the virtual machines we generate an ssh keypair so that each vm can be managed by the same ssh key for ease of administration.</p>

<h2 id="create-three-virtual-machines">Create three virtual machines</h2>

<p>Finally we can provision the virtual machines. For each VM we give it a unique name that aligns with the name of it&rsquo;s NIC and OS disk. We place it in the availability set that we created and associate it with the public key of the ssh key pair that we generated previously.</p>

<h2 id="install-docker-on-all-three-nodes">Install docker on all three nodes</h2>

<p><strong>On all three nodes</strong> you have to install docker. Repeat these commands on each node via an ssh session.</p>

<h3 id="ssh-to-the-specific-node">SSH to the specific node</h3>

<p>In order to reach each individual node via the load balancer you have to ssh to the correct port based on how we setup the NAT rules earlier.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell"><span style="color:#75715e"># node 1</span>
ssh -i ~/.ssh/docker_rsa wshaddix@&lt;load balancer ip address&gt; -p 4221

<span style="color:#75715e"># node 2</span>
ssh -i ~/.ssh/docker_rsa wshaddix@&lt;load balancer ip address&gt; -p 4222

<span style="color:#75715e"># node 3</span>
ssh -i ~/.ssh/docker_rsa wshaddix@&lt;load balancer ip address&gt; -p 4223</code></pre></div>
<h3 id="setup-the-docker-apt-repository">Setup the docker apt repository</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">sudo apt-get update

sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    software-properties-common

curl -fsSL https<span style="color:#960050;background-color:#1e0010">:</span>//download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

sudo add-apt-repository \
   <span style="color:#e6db74">&#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
</span><span style="color:#e6db74">   </span>$(lsb_release -cs)<span style="color:#e6db74"> \
</span><span style="color:#e6db74">   stable&#34;</span></code></pre></div>
<h3 id="install-docker-ce">Install Docker CE</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">sudo apt-get update

sudo apt-get install docker-ce=17.09.1~ce-0~ubuntu</code></pre></div>
<h3 id="verify-that-docker-is-working-correctly">Verify that docker is working correctly</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">sudo docker run hello-world</code></pre></div>
<h3 id="manage-docker-as-a-non-root-user">Manage docker as a non-root user</h3>

<p>Right now anytime you interact with the docker cli you have to prefix the <code>docker</code> command with <code>sudo</code>. If you want
 to allow your user to run the docker cli as non-root you can create a docker group and add your user to it. Note that you&rsquo;ll have to log out and back in for this change to take effect.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">sudo usermod -aG docker $USER</code></pre></div>
<h3 id="configure-docker-to-start-on-boot">Configure docker to start on boot</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">sudo systemctl enable docker</code></pre></div>
<h2 id="initialize-the-docker-swarm">Initialize the docker swarm</h2>

<p>Make sure you run the following command on the <strong>swarm manager node</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">docker swarm init --advertise-addr 10.0.0.4</code></pre></div>
<p>The output of the above command will tell you what you need to run on the worker1 and worker2 nodes to join to the cluster.</p>

<h2 id="add-the-worker-nodes-to-the-cluster">Add the worker nodes to the cluster</h2>

<p>On the worker nodes run the command (my example is below) indicated when you initialized the swarm cluster from the previous step.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">docker swarm join --token &lt;your swarm cluster<span style="color:#960050;background-color:#1e0010">&#39;</span>s join token&gt; 10.0.0.4<span style="color:#960050;background-color:#1e0010">:</span>2377</code></pre></div>
<h2 id="verify-the-swarm-cluster-is-up">Verify the swarm cluster is up</h2>

<p>On the manager node run the following command to ensure that the swarm is running with three nodes.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">docker node ls</code></pre></div>
<h2 id="cleaning-up">Cleaning up</h2>

<p>After you are done and ready to deprovision all of the resources that we&rsquo;ve created so that you are not billed for them, you can simply delete the resource group.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">az group delete -n dev-docker-swarm-us-east</code></pre></div>
<p>You also may want to delete your docker_rsa ssh keypair if you are going to re-run these steps in the future.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">rm ~/.ssh/docker_rsa*</code></pre></div>
<p>You may (or may not) also want to remove the three nodes from your <code>~/.ssh/known_hosts</code> file</p>

<h2 id="saving-time">Saving time</h2>

<p>If you are creating and removing swarm clusters frequently it is faster to run all of the commands at once as opposed to copy/paste/running each one. I&rsquo;ve setup gists to speed up the process.</p>

<h3 id="create-the-entire-three-node-swarm-cluster-on-azure">Create the entire three node swarm cluster on Azure</h3>

<p>After you&rsquo;ve logged into your Azure account you can run</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">wget -O - https<span style="color:#960050;background-color:#1e0010">:</span>//gist.githubusercontent.com/wshaddix/3acf084908f31d7c18f1f20f53b19147/raw/bf4ea5aa97a92020be50cd1c0cc2f7c7a6b65fbc/Setting<span style="color:#66d9ef">%</span>2520up<span style="color:#66d9ef">%</span>2520docker<span style="color:#66d9ef">%</span>2520swarm<span style="color:#66d9ef">%</span>2520on<span style="color:#66d9ef">%</span>2520azure | bash</code></pre></div>
<p>This will setup the three virtual machines.</p>

<h3 id="install-docker">Install Docker</h3>

<p>Next, you can ssh into each of the three nodes and run</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">wget -O - https<span style="color:#960050;background-color:#1e0010">:</span>//gist.githubusercontent.com/wshaddix/91058d471c525050f005e98eda85e3d3/raw/46de5d48bd4c4e51a9701e743c85fbf4dc3a3ce4/Install<span style="color:#66d9ef">%</span>2520Docker<span style="color:#66d9ef">%</span>2520on<span style="color:#66d9ef">%</span>2520Ubuntu<span style="color:#66d9ef">%</span>252017.04 | bash</code></pre></div>
<h3 id="initialize-swarm-mode">Initialize swarm mode</h3>

<p>Now you&rsquo;ve got your virtual machines provisioned and docker installed you can just run the commands listed above to initialize the swarm and join the worker nodes.</p>
</article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="http://www.wesshaddix.com/tags/docker"><span class="tag">Docker</span></a></li>
        
          <li><a href="http://www.wesshaddix.com/tags/docker-swarm"><span class="tag">Docker-Swarm</span></a></li>
        
      </ul>
      
      <p class="post-copyright">
        © This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. Please give a reference to this source if you would like to quote or reproduce.
      </p>
    </footer>
    
      <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "wesshaddix" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
    
  </section>
  <footer class="site-footer">
  <p>© 2017 Wes Shaddix</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank">Nuo</a>.</p>
  
</footer>



<script async src="//cdn.bootcss.com/video.js/6.2.8/alt/video.novtt.min.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\[','\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>

<script src="http://www.wesshaddix.com/js/bundle.js"></script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-587905-4', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>





  </body>
</html>
